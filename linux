---------------------------------------FILE----------------------------------
- Kernel buffer: Khi read/write file, thay vi ghi truc tiep vao file trong o cung(ton time), se copy vao mot buffer trong kernel. Sau do co kernel thread thu thap va ghi buffer do vao o cung, roi lam sach buffer de tai su dung.
+ file bao gồm 2 phần: dâta và metadata(owner,quyền truy cập file, kích thước, số hardlink đến file,...)
# Có 2 cách đồng bộ thủ công dữ liệu giữa kernel buffer và ổ cứng:
1Synchronized I/O data integrity chỉ yêu cầu nội dung data của file được đồng bộ giữa tiến trình và file
2Synchronized I/O file integrity yêu cầu tất cả nội dung của file bao gồm data và metadata phải được đồng bộ giữa tiến trình gọi và ổ cứng

--------------------------------------PROCESS----------------------------------
- Chương trình (program) là một file chạy được (executable) chứa các chỉ lệnh (instruction) được viết để thực thi một công việc nào đó trên máy tính
+tiến trình (process) là một phiên bản đang chạy của một chương trình. Tiến trình được gọi là thực thể chủ động (active entity) để phân biệt với chương trình, vì nó sẽ được copy từ ổ cứng sang bộ nhớ RAM để chạy trên hệ điều hành máy tính 
# Cấu trúc bộ nhớ của tiến trình:
					Heap
				
					Stack

					Uninitialized data segment(bss)

					Initialized data

					Text code

-Text code: Chứa các chỉ lệnh ngôn ngữ máy (machine-language instruction) của chương trình mà tiến trình đó chạy. Text segment chính là các chỉ lệnh được biên dịch từ source code của lập trình viên cho chương trình đó. Nội dung của phân vùng này không thay đổi trong suốt quá trình process tồn tại nên được kernel thiết lập chế độ read-only để bảo vệ khỏi sự truy cập vô tình hay cố ý của người dùng. Như đã nói ở trên, vì nhiều tiến trình có thể chạy một chương trình nên text segment cũng được thiết lập sharable để các tiến trình có thể sử dụng chung để tiết kiệm tài nguyên.
+Initialized data segment(bss): Vùng này chứa các biến toàn cục (global) và biến static mà đã được khởi tạo từ code của chương trình. Giá trị của các biến này được đọc từ các file thực thi khi chương trình được tải vào RAM
#Uninitialized data segment: Còn được gọi là vùng bss segment. Segment này chứa các biến toàn cục và static mà 'chưa' được khởi tạo từ source code. Ví dụ khi lập trình viên khai báo biến tĩnh “static var;”, biến var sẽ được chứa ở vùng này và được khởi tạo giá trị 0, khi một chương trình được lưu trữ vào ổ cứng, không cần thiết phải cấp phát tài nguyên cho uninitialized data segment; thay vào đó chương trình chỉ cần nhớ vị trí và kích thước biến được yêu cầu cho vùng này, các biến này sẽ được cấp phát run time khi chương trình được tải vào RAM.
-Stack segment: Chứa stack frame của tiến trình. Chúng ta sẽ tìm hiểu sâu hơn về stack và stack frame ở phần dưới đây. Tạm thời hiểu là khi 1 hàm được gọi, một stack frame sẽ được cấp phát cho hàm đó (các biến được khai báo trong hàm, các đối số truyền vào hay giá trị return) và sẽ bị thu hồi khi hàm đó kết thúc. Vì vậy, stack segment có thể giãn ra hoặc co lại khi tiến trình cấp phát/thu hồi các stack frame.
 Khi một hàm được gọi, một stack frame của hàm đó được cấp phát và push vào stack; và stack frame này sẽ được thu hồi khi hàm đó return.thu hồi khi hàm đó return.
Mỗi stack frame chứa các thông tin sau:
1.Đối số (argument) của hàm và các biến cục bộ (local variable): Các biến này còn được gọi là biến tự động (automatic variable) vì chúng sẽ tự động được tạo ra khi hàm được gọi và tự động biến mất khi hàm đó return (vì stack frame cũng biến mất).
2.Call linkage information: Các hàm khi chạy sẽ sử dụng các thanh ghi của CPU, ví dụ như thanh ghi program counter (pc) lưu chỉ lệnh tiếp theo được thực thi. Mỗi lần một hàm (ví dụ hàm X) gọi hàm khác (ví dụ hàm Y), giá trị các thanh ghi mà hàm X đang dùng sẽ được lưu vào stack frame của hàm Y; và sau khi hàm Y return, các giá trị thanh ghi này sẽ được phục hồi cho hàm X tiếp tục chạy.
+Heap segment: Là vùng bộ nhớ lưu các biến được cấp phát động (dynamic allocate) tại thời điểm run time. Tương tự như stack segment, heap segment cũng có thể giãn ra hoặc co vào khi một biến được cấp phát hoặc free.
#Typically two processes communicate with each other on a single system through one of the following inter process communication techniques.

Pipes
Message queues
Shared memory

	`fork(): Tạo ra 1 bản sao cho bộ nhớ hiện tại của process
	`exec(): Tạo process mới tại điểm bắt đầu tiến trình
	`wait(): Block process cho đến khi 1 trong các process con kết thúc
	`system(): Cho thực hiện một command line trong C





--------------------------------------------------------------------THREAD--------------------------------------------------------------------------------
- Thread là một cơ chế cho phép một ứng dụng thực thi đồng thời nhiều công việc (multi-task)
+ Thread là một thành phần của tiến trình, một tiến trình có thể chứa một hoặc nhiều thread
#Các thread trong tiến trình chia sẻ các vùng nhớ toàn cục (global memory) của tiến trình bao gồm initialized data, uninitialized data và vùng nhớ heap
Một thread đang thực thi có thể được kết thúc bằng một trong các cách sau:
1.Hàm bắt đầu của thread thực thi câu lệnh return
2.Một hàm bất kỳ trong thread gọi hàm pthread_exit(), chúng ta sẽ nói về hàm này ở dưới đây
3.Thread bị hủy bỏ bằng hàm pthread_cancel()
4.Một thread bất kỳ của tiến trình gọi hàm exit() hoặc thread chính của tiến trình (hàm main()) gọi return. Cả 2 cách này đều có tác dụng kết thúc tiến trình đang chạy và tất nhiên cả các thread của tiến trình đó.
-một thread được tạo ra cũng giống như một tiến trình con, cần phải được theo dõi trạng thái và thu hồi tài nguyên khi kết thúc, tránh việc tạo ra zombie thread gây lãng phí tài nguyên của tiến trình
+Trong Linux, một pthread khi được tạo ra sẽ mặc định là joinable thread. Do đó, thread sau khi kết thúc sẽ được “join” để lấy được trạng thái kết thúc và thu hồi tài nguyên của nó.
#Một thread được thiết lập là detached thread khi lập trình viên không cần quan tâm đến trạng thái kết thúc của nó. Khác với joinable thread, kernel sẽ tự động thu hồi tài nguyên của detached thread khi nó kết thúc.
-#Thuật ngữ critical section (vùng trọng yếu) dùng để chỉ đoạn code mà truy cập vào tài nguyên toàn cục (global resource); đoạn code này nên được chạy hết từ đầu đến cuối bởi mỗi thread thay vì bị ngắt khi có một thread khác xen vào đọc hoặc thay đổi các biến toàn cục trong đó.Như vậy, critical section nên được bảo vệ để khi các thread đồng thời chạy vào, nó phải chờ cho đến khi thread đang chạy thực thi xong và ra khỏi thì mới được chạy vào. Việc này gọi là đồng bộ thread (thread synchronization)
1.Kỹ thuật mutual exclusion (gọi tắt là mutex) dùng để bảo vệ tài nguyên chia sẻ (shared variable) mà chủ yếu là biến chia sẻ (shared variable) giữa các thread. Mỗi vùng critical section sẽ được bảo vệ trong phòng và có một cái khóa ở cửa, một thread trước khi chạy vào critical section sẽ khóa lại rồi vào làm những gì mình muốn làm; sau khi xong việc nó sẽ mở khóa để cho các thread khác truy cập. Các thread khác nếu thấy cửa đang khóa thì phải chờ (đi vào trạng thái blocked) cho đến khi thread trước mở khóa; sau đó nó tiếp tục khóa lại rồi chạy vào critical section và mở khóa ra sau khi xong việc.
- Trạng thái một thread khóa một mutex mà rơi vào trạng thái chờ không thể giải thoát được gọi là deadlock. Có 2 trường hợp:Thread A khóa một mutex mà chính nó trước đó đã bị khóa bởi chính nó hoặc Thread A khóa Mutex1 và vào critical section, sau đó cố gắng khóa một Mutex2 mà thread B đang giữ. Trong khi đó, thread B đang khóa Mutex2 và lại cố gắng khóa Mutex1 ở trong critical section.

	`pthread_create():tao ra thread moi
	`pthread_exit():
	`pthread_join() sẽ block chương trình và chờ cho thread với ID truyen vao kết thúc
	`pthread_detach(), chuyển thread thành detached thread
	`pthread_mutex_lock, pthread_mutex_unlock



-------------------------------------------------------SOCKET----------------------------------------------------
-Socket là một điểm cuối (end-point) của liên kết giao tiếp hai chiều (two-way communication) giữa hai chương trình chạy trên mạng. Nghĩa là một socket được sử dụng để cho phép 1 process nói chuyện với 1 process khác.
1.Stream sockets: Dựa trên giao thức TCP (Tranmission Control Protocol), là giao thức hướng luồng (stream oriented). Việc truyền dữ liệu chỉ thực hiện giữa 2 tiến trình đã thiết lập kết nối. Giao thức này đảm bảo dữ liệu được truyền đến nơi nhận một cách đáng tin cậy, đúng thứ tự nhờ vào cơ chế quản lý luồng lưu thông trên mạng và cơ chế chống tắc nghẽn. Dùng cho mạng WAN, tốc độ thấp
2.Datagram sockets: Dựa trên giao thức UDP (User Datagram Protocol), là giao thức hướng thông điệp (message oriented). Việc truyền dữ liệu không yêu cầu có sự thiết lập kết nối giữa tiến quá trình. Ngược lại với giao thức TCP thì dữ liệu được truyền theo giao thức UDP không được tin cậy, có thế không đúng trình tự và lặp lại. Tuy nhiên vì nó không yêu cầu thiết lập kết nối không phải có những cơ chế phức tạp nên tốc độ nhanh…ứng dụng cho các ứng dụng truyền dữ liệu nhanh như chat, game….. Dùng cho majng LAN, Tốc độ truyền cao, VolP truyền tốt qua UDP

+TCP Server –
+using create(), Create TCP socket.
+using bind(), Bind the socket to server address.
+using listen(), put the server socket in a passive mode, where it waits for the client to approach the server to make a connection
+using accept(), At this point, connection is established between client and server, and they are ready to transfer data.
+Go back to Step 3.
+TCP Client –
+Create TCP socket.
+connect newly created client socket to server.

UDP Server:
Create UDP socket.
Bind the socket to server address.
Wait until datagram packet arrives from client.
Process the datagram packet and send a reply to client.
Go back to Step 3.
UDP Client:
Create UDP socket.
Send message to server.
Wait until response from server is recieved.
Process reply and go back to step 2, if necessary.
Close socket descriptor and exit.




	`socket()
	`bind
	`listen()
	`accept()

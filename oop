- Object: Đối tượng là một thực thể trong đời thực. Một đối tượng có thuộc tính và phương thức. VD: Con chó có thuộc tính màu, lông, tuổi, giống,..Phương thức: sủa, ăn, tiêu hóa, chạy. Đối tượng là thể hiện của 1 lớp, tát cả các thành viên cua lớp được truy cập thông qua đối tượng
+ Class: Là 1 nhóm của đối tượng. Một class sẽ định nghĩa danh sách những tính chất và phương thức đối tuowjjng trong class sở hữu.
# Trừu tượng(Abstraction): Mục tiêu chính của nó là làm giảm sự phức tạp bằng cách ẩn các chi tiết không liên quan trực tiếp tới người dùng (người dùng ở đây không phải người dùng cuối mà là lập trình viên). Điều đó cho phép người dùng vẫn thực hiện được các công việc cần thiết dựa trên một thực thể trừu tượng được cung cấp mà không cần hiểu hoặc thậm chí không nghĩ về tất cả sự phức tạp ẩn giấu bên trong..Tập trung vào cốt lõi của đối tượng, không quan tâm những thứ ko liên quan. Ví dụ: Khi nói cái quạt chỉ biết là vật làm mát ko biết là quạt cây, quạt treo tường
Dữ liệu (data) và một số hàm (methods) không cần thiết đưa ra bên ngoài sẽ được đưa vào trong class và chỉ định đặc tả truy cập là private (hoặc protected). Các data hoặc methods đó sẽ không thể truy cập từ bên ngoài của class đó. Ở cảnh giới này trừu tượng giúp cho code dễ hiểu hơn vì nó tập trung vào các tính năng / hành động cốt lõi và không tập trung vào các chi tiết nhỏ nhặt. Ngoài ra nó còn giúp chương trình dễ bảo trì, hạn chế lỗi do truy cập data bừa bãi, sai cách. Ở level này có thể coi Abstraction = Encapsulation + Data Hiding
- Tính đóng gói (encapsulation): Tính đóng gói (Encapsulation) chỉ đơn giản là việc kết hợp một bộ các dữ liệu (data) liên quan đến nhau cùng với một bộ các hàm/phương thức (functions/methods) hoạt động trên các dữ liệu đó, “gói” tất cả vào trong một cái gọi là class.  Các thực thể của các class thì được gọi là các đối tượng (objects) trong khi class giống như một công thức được sử dụng để tạo ra các đối tượng đó.
+ Tính thừa kế (inheritance): Ưu điểm của đặc tính kế thừa: sử dụng lại các đoạn code đã có trong chương trình 1 cách hiệu quả. Khi tạo 1 class, thay vì việc viết 1 class mới hoàn toàn, người lập trình viên có thể kế thừa một số thuộc tính và phương thức từ 1 class đã có trong project. Class đã có trước đấy gọi là lớp cơ sở (Base Class), class kế thừa từ Base Class (hay superclass) gọi là lớp dẫn xuất (Derived Class).
# Tính đa hình (polymorphism): Polymorphism có 2 dạng:

Dạng 1 – Compile time Polymorphism: Một class có nhiều hàm cùng tên nhưng khác nhau về số lượng tham số hoặc kiểu dữ liệu của tham số. Khi call hàm cùng tên đó thì trong quá trình biên dịch, compiler sẽ quyết định hàm nào (trong số các hàm cùng tên) sẽ được call dựa trên số lượng tham số và kiểu dữ liệu của tham số truyển vào hàm. Việc định nghĩa các hàm cùng tên được gọi là overloading – nạp chồng hàm.
Dạng 2 – Runtime Polymorphism: Cùng một class có thể cho ra nhiều biến thể, không phải được định nghĩa bởi lớp đó, mà bởi các lớp con của nó. Đây là một phương pháp để định nghĩa lại hành vi của lớp cơ sở mà không phải sửa code (còn gọi là implementation) của lớp cơ sở. Nếu call hàm của đối tượng của lớp dẫn xuất thông qua con trỏ của lớp cơ sở thì việc hàm nào (của lớp cơ sở hay). Runtime Polymorphism được thực hiện bằng phương pháp overriding – ghi đè phương thức.
Ở lớp cha có phương thức là Draw, tùy theo phuong thức lớp con có thể vẽ là hình vuông, hình tròn, hình chữ  nhật.
- Khai bao class:
	class HocSinh{
	    //Khai bao (cai dat) thuoc tinh
	    //Khai bao (cai dat) phuong thuc
	    //Khai bao thuoc tinh, giong khai bao bien
	    //Khai bao phuong thuc giong khai bao ham
	    //private:  chi su dung trong class do thoi
	    //public: the gioi ben ngoai co the su dung
	    //protected:
	private:
	    string HoTen;
	    void xuat();
	public:
	    string DiaChi;
	    void nhap();
	    float tinhDiem();

	};

	int main()
	{
	    HocSinh HS;//cach khoi tao doi tuong tu class
	    HS.DiaChi = "Ha Noi";
	    HS.nhap();//Cach truy cap den thanh phan cua class

	    return 0;
	}
+ Co 2 cach dinh nghia phuong thuc class, Khai bao va dinh nghia trong class, hai bao trong class va dinh nghia ben ngoai. Cu phap: KieuTraVe TenClass::TenPhuongThuc
# Con trỏ this tham chiếu đến đối tượng đang gọi hàm thành phần. . Con trỏ this trong C++ là một từ khóa đề cập đến thể hiện hiện tại của lớp, là một tham số ẩn với tất cả hàm thành viên. Vì thế, bên trong một hàm thành viên, con trỏ this có thể tham chiếu tới đối tượng đang gọi. Cach 1: Trỏ đến thành phần class hiện tại, Cách 2: Trả về object hiện tại
- Đối tượng có thể là tham số truyền vào của phương thức
+ Hàm khởi tạo- Constructor là hàm mặc định được dùng để khởi tạo đối tượng, cùng tên với class, khong co kieu tra ve, va phải trong tầm vực public. Có 3 loại
1Constructor mặc định
2.Constructor có tham số
3.Constructor sao chép
#Thuộc tính tĩnh- static data member: 1 bản duy nhất tồn tại trong suốt quá trình chạy của chương trình, dùng chung cho tất cả đối tượng của class, phải định nghĩa bên ngoài clss

- Hàm bạn:
-Hàm bạn trong c++ là hàm tự do, không thuộc lớp. Tuy nhiên hàm bạn trong c++ có quyền truy cập các thành viên private của lớp.
- Một lớp trong c++ có thể có nhiều hàm bạn, và chúng phải nằm bên ngoài class.
-Hàm bạn không thuộc về class của bạn mình (ví dụ: DienTich ko thuộc HinhChuNhat, ko thể gọi DienTich từ HCN được);-
-Thông thường hàm bạn có tham sô truyền vào là một object=>ko biết bạn của ai;
-Hàm bạn không thể truy cập các thuộc tính của hàm bạn mình.
-Hàm bạn khai báo trong public hay private đều được
-Phuowng thức của một class có thể làm bạn của một class khác

+Nap chồng toán tử có 3 cách: member-function, non-member function, friend member function. Member function bị giới hạn tham số truyền vào, dùng non-mem phải dùng getter và setter để truy cập vào thuộc tính private. Dùng friend function linh hoạt hơn.
#Dung getter và setter để lấy dữ liệu private ra sử dụng

-Virtual: thêm trước phương thức
- Chỉ hoạt động thông qua con trỏ
- chỉ cần thêm trước khai báo, không cần them trước định nghĩa
- nếu 1 hàm khai báo là ảo ở lớp cơ sở, nó sẽ ảo ở mọi lớp con
- Tên phương thức ở lớp cơ sở và dẫn xuất phải trung nhau

+ lớp trừu tượng là lớp có ít nhất 1 phương thức thuần ảo, có thuộc tính và phương thức như lớp bình thường
+ phương thức thuần ảo bắt đầu bằng virtual và kết thúc bằng 0. VD: virtual void f() = 0;
+ Không thể tạo đối tượng từ lớp trừu tượng, nhứng có thể tạo con trỏ và tham chiếu
+ Lớp trừu tượng dùng cho mục đích chủ yếu là trỏ đến lớp con (upcasting
+ lớp kế thừa từ lớp thuần ảo cũng phải định nghĩa hàm thuần, nếu không lớp đó cũng thành lớp trừu tượng

-Dùng phương thức ảo khi ở class cha có thông tin tính toán được, nếu ko tính toán mà chỉ tính toán ở các class con, dùng phương thức thuần ảo








----------------------Tong ket------------------------------------
1.Con trỏ this
Mỗi đối tượng trong C++ có sự truy cập tới vị trí riêng của nó thông qua một con trỏ quan trọng gọi là con trỏ this. Con trỏ this trong C++ là một từ khóa đề cập đến thể hiện hiện tại của lớp, là một tham số ẩn với tất cả hàm thành viên. Vì thế, bên trong một hàm thành viên, con trỏ this có thể tham chiếu tới đối tượng đang gọi.
Các hàm friend không có con trỏ this, bởi vì friend không phải là các thành viên của một lớp. Chỉ có các hàm thành viên trong C++ là có con trỏ this.

2.Static
Khi chúng ta khai báo một thành viên của một lớp là static, khi đó dù cho có bao nhiêu đối tượng của lớp được tạo, thì sẽ chỉ có một bản sao của thành viên static.Một thành viên static chỉ cần khởi tạo 1 lần và được chia sẻ cho tất cả đối tượng của lớp. Tất cả dữ liệu static được khởi tạo về 0 khi đối tượng đầu tiên được tạo. Chúng ta không thể khởi tạo thành viên static trong định nghĩa lớp, nhưng nó có thể được định nghĩa bên ngoài lớp đó bởi việc khai báo lại biến static như trong ví dụ sau, sử dụng toán tử phân giải phạm vi :: để nhận diện lớp nào sở hữu nó
Biến static là private, dùng hàm static getter ở tầm vực public để có thể truy cập


3.Template
“Template” là từ khóa trong C++, chúng ta có thể hiểu rằng là nó một kiểu dữ liệu trừu tượng, đặc trưng cho các kiểu dữ liệu cơ bản. “Template” là từ khóa báo cho trình biên dịch rằng đoạn mã sau đây định nghĩa cho nhiều kiểu dữ liệu và mã nguồn của nó sẽ được compile sinh ra tương ứng cho từng kiểu dữ liệu trong quá trình biên dịch.

Có 2 loại “template” cơ bản:

Function template: là một khuôn mẫu hàm, cho phép định nghĩa các hàm tổng quát thao tác cho nhiều kiểu dữ liệu.
Class template: là một khuôn mẫu lớp, cho phép định nghĩa các lớp tổng quát cho nhiều kiểu dữ liệu.

4.Hàm bạn
Nếu một hàm được định nghĩa là một hàm bạn (Friend function) trong C++, thì dữ liệu được bảo vệ (protected) và riêng tư (private) của một lớp có thể được truy cập bằng cách sử dụng hàm. Hàm bạn phải truy cập dữ liệu thông qua đối tượng vì không phải hàm thành viên.
Một lớp bạn (friend class) có thể truy cập cả các thành viên riêng tư và được bảo vệ của lớp mà nó đã được khai báo là friend.Khi một lớp trở thành một lớp bạn, mọi hàm thành viên của lớp đó đều trở thành hàm bạn.
